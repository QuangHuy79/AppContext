Káº¾ HOáº CH STEP-BY-STEP â€” Task C (Runtime Stability & Side-Effect Correction)
Má»¥c tiÃªu ngáº¯n gá»n
Loáº¡i bá» side-effect khÃ´ng idempotent (double-run trong StrictMode).

NgÄƒn race giá»¯a Hydration â†” AppProvider â†” DataSync â†” API.

Báº£o Ä‘áº£m cleanup (timers/intervals/fetches/listeners).

Giá»¯ nguyÃªn kiáº¿n trÃºc, sá»­a cÃ³ kiá»ƒm soÃ¡t tá»«ng file.

Tá»•ng quan thá»© tá»± (ngáº¯n)
Backup hiá»‡n tráº¡ng (git stash / commit)

Refactor StatePersistenceContext (guard double hydrate)

Hardening AppProviderInner effects (guard nulls + listener setup guard)

Make API cancellable (AbortController)

Harden DataSyncContext (interval cancel, idempotent start)

Ensure hooks safe defaults (Settings, Device, UI)

Sweep wrappers / clusters for missing cleanup (NetworkCluster, DeviceCluster, UICluster)

Add single runtime:ready event (guarded)

Smoke tests + Profiler checks

Playbook: what to revert if break

BÆ°á»›c-chi tiáº¿t (má»—i bÆ°á»›c = hÃ nh Ä‘á»™ng + git + test)
BÆ°á»›c 0 â€” Chuáº©n bá»‹ (báº¯t buá»™c)
TrÆ°á»›c khi lÃ m gÃ¬: commit táº¥t cáº£ hiá»‡n tráº¡ng.

git add .
git commit -m "WIP: pre Task C backup"
Náº¿u khÃ´ng dÃ¹ng git: táº¡o báº£n sao thÆ° má»¥c src_backup_YYYYMMDD.

Má»¥c Ä‘Ã­ch: cÃ³ thá»ƒ revert ngay náº¿u cáº§n.

BÆ°á»›c 1 â€” Refactor StatePersistenceContext (priority HIGH)
Má»¥c tiÃªu: trÃ¡nh double-hydrate / race.

Thao tÃ¡c:

Má»Ÿ src/context/StatePersistenceContext.jsx.

ThÃªm const hasHydratedRef = useRef(false);

Trong effect restore, trÆ°á»›c khi parse saved, if (hasHydratedRef.current) return; hasHydratedRef.current = true;

Giá»¯ mounted flag & finally setIsReady(true).

Test nhanh:

npm run dev â†’ console: chá»‰ 1Ã— â€œ[HYDRATE] Restoring stateâ€¦â€ (in Dev might still see 2 logs if StrictMode double-mount but hydrate action only fired once).

Náº¿u tháº¥y errors, revert.

Pass: no duplicate dispatch HYDRATE_APP_STATE and no race errors.

BÆ°á»›c 2 â€” Harden AppProviderInner effects (priority HIGH â†’ MED)
Má»¥c tiÃªu: ëª¨ë“  useEffect trong AppProviderInner safe (guard null, avoid dispatch when not ready).

Thao tÃ¡c:

Má»Ÿ src/context/AppContext.jsx (AppProviderInner).

Trong tá»«ng effect:

if (isOnline !== undefined) dispatch(...)

if (deviceInfo) dispatch(...)

For toast effect: if (!toast) return; (already exists) â€” ensure no destructuring of undefined.

For addEventListener effect: add listenersSetupRef to prevent duplicate add/remove across double mount:

const listenersSetupRef = useRef(false);
useEffect(() => {
  if (listenersSetupRef.current) return;
  listenersSetupRef.current = true;
  window.addEventListener(...);
  return () => {
    window.removeEventListener(...);
    listenersSetupRef.current = false;
  };
}, []);
Test nhanh:

Toggle online/offline â†’ no duplicate toast, no repeated addEvent warnings.

Check console for â€œsetState on unmountedâ€ errors.

Pass: no event duplication, no setState on unmounted.

BÆ°á»›c 3 â€” Make API requests cancellable (priority HIGH)
Má»¥c tiÃªu: Prevent fetch results updating unmounted components or causing race.

Thao tÃ¡c:

If you use central apiService.js: modify request to accept signal or return { promise, controller }.

If using APIContext.request put const controller = new AbortController(); signal = controller.signal and expose controller to caller or ensure components create their own controller and call controller.abort() in cleanup.

Example change in apiService.request:

const controller = new AbortController();
const res = await fetch(url, { ...opts, signal: controller.signal });
For UI components or effects calling .get(), create controller in effect and abort on cleanup.

Test nhanh:

Start long fetch, unmount component quickly; ensure no unhandled promise rejection and no setState on unmounted.

Pass: no warnings when navigating away mid-fetch.

BÆ°á»›c 4 â€” Harden DataSyncContext (priority HIGH)
Má»¥c tiÃªu: Auto-sync loop idempotent, cancelable, single start.

Thao tÃ¡c:

Add mountedRef = useRef(true) and autoSyncStartedRef = useRef(false).

Start interval only if autoSyncStartedRef.current === false, set true.

When unmount, clearInterval and mountedRef.current = false.

syncNow should check if (!mountedRef.current) return; when applying results or updating UI.

If syncNow triggers internal async calls, check mountedRef before dispatching.

Test nhanh:

Watch console while online + authenticated: ensure tick runs only once per interval and cancels on reload.

Simulate quick mount/unmount: no leftover interval.

Pass: no duplicate sync runs after StrictMode mount.

BÆ°á»›c 5 â€” Safe defaults in hooks (priority MED)
Má»¥c tiÃªu: Hooks never return undefined shapes so consumers don't crash.

Thao tÃ¡c:

useSettings: return { state: { theme: 'light', language: 'en' }, ... } if context missing OR keep throwing error (but be consistent). Best: throw in dev, but for safety return defaults in prod.

useDevice: ensure returns { width, height, isMobile, ... } always.

useUI: ensure stable API (toast, loading, showToast).

Test nhanh:

Remove providers locally and mount UICluster to see predictable behavior (better to test with providers present).

Pass: no Cannot read properties of undefined errors when components mount.

BÆ°á»›c 6 â€” Sweep clusters & wrappers for cleanup (priority MED â†’ LOW)
Files to inspect:

runtime/clusters/* â€” ensure Suspense, cleanup, no inline functions that change every render.

context/wrappers/* â€” ensure wrappers don't create side effects without cleanup.

Thao tÃ¡c:

Wrap cluster components in React.memo where children are stable.

Ensure any effect has cleanup.

Test nhanh:

Profiler: mount App, toggle theme, open sidebar â€” ensure bounded renders.

Pass: profiler improvements, fewer wasted renders.

BÆ°á»›c 7 â€” runtime:ready event (single, guarded) (priority LOW)
Má»¥c tiÃªu: Emit one app:runtime:ready event once after hydration and providers ready.

Thao tÃ¡c:

In AppRuntimeClient after AppProvider mount & StatePersistence isReady, do:

const readyFiredRef = useRef(false);
useEffect(() => {
  if (readyFiredRef.current) return;
  readyFiredRef.current = true;
  window.dispatchEvent(new CustomEvent('app:runtime:ready'));
}, []);
Test nhanh:

Listen in console, ensure single event.

Pass: single event emitted.

BÆ°á»›c 8 â€” Smoke tests & Profiler (priority MED)
Checklist to run:

npm run dev

Open console; expect no runtime errors.

Toggle theme, open sidebar, login (mock), trigger DataSync â†’ monitor toasts + no errors.

Profiler: record before/after applying patches for 5 interactions; compare render counts & time.

If failures: revert commit, inspect error line, fix specific file.

Rollback plan
If any patch breaks: git reset --hard HEAD (or git checkout -- .), then restore previous commit.

Keep small commits per patch so you can revert only that file.

=====================================================================
â–¶ï¸ Phase tiáº¿p theo: C-5 â€“ Runtime Orchestration & Contract Hardening
Sau C-4, tráº¡ng thÃ¡i hiá»‡n táº¡i cá»§a báº¡n lÃ  chuáº©n Ä‘á»ƒ khÃ³a kiáº¿n trÃºc.
Má»¥c tiÃªu C-5 lÃ  Ä‘áº£m báº£o runtime cháº¡y á»•n Ä‘á»‹nh, predictable, khÃ´ng phá»¥ thuá»™c thá»© tá»± mount ngáº«u nhiÃªn.

ğŸ¯ Má»¥c tiÃªu C-5
RuntimeOrchestrator lÃ m chá»§ vÃ²ng Ä‘á»i

Provider chá»‰ emit signal â€“ khÃ´ng tá»± quyáº¿t

Contract giá»¯a Runtime â†” Contexts Ä‘Æ°á»£c â€œÄ‘Ã³ng bÄƒngâ€

Chuáº©n bá»‹ cho Production Hardening

ğŸ§© C-5 gá»“m 3 bÆ°á»›c (Ä‘i tá»«ng bÆ°á»›c, khÃ´ng nháº£y)
C-5.1 â€“ Provider Readiness Contract
ğŸ‘‰ Check & chuáº©n hÃ³a:

APIProviderWrapper

AuthWrapper

DataWrapper

DataSyncWrapper

NotificationWrapper

YÃªu cáº§u:

âœ… chá»‰ emitReady("xxx")

âŒ khÃ´ng side-effect logic

âŒ khÃ´ng fetch / hydrate / retry

C-5.2 â€“ RuntimeOrchestrator Gate
ğŸ‘‰ Runtime chá»‰ render App khi:

API ready

Auth initialized

StatePersistence hydrated

KhÃ´ng Ä‘á»§ â†’ block render

C-5.3 â€“ Runtime Boundary & Fail-safe
ğŸ‘‰ Äáº£m báº£o:

Provider fail â†’ runtime degrade (khÃ´ng crash)

Missing provider â†’ warning rÃµ rÃ ng

KhÃ´ng infinite retry / double mount


Chá»‘t roadmap má»›i (ráº¥t rÃµ)
ğŸ”· C-6 = Router & Page Integration
C-6.1 â€“ Gáº¯n Router vÃ o AppRuntime
C-6.2 â€“ Lazy-load Pages theo Route
C-6.3 â€“ Auth-aware Route (Private / Public)
C-6.4 â€“ Runtime Suspense Strategy (global vs per-route)

â¡ï¸ Sau khi xong C-6
â¡ï¸ Quay láº¡i C-7: Runtime Guard & Hardening
â¡ï¸ Guard lÃºc nÃ y sáº½ ráº¥t chÃ­nh xÃ¡c